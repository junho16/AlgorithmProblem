package leetcode;

import javax.management.QueryEval;
import java.util.LinkedList;
import java.util.Queue;

/**
 * 1293. 网格中的最短路径
 * 给你一个 m * n 的网格，其中每个单元格不是 0（空）就是 1（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。
 *
 * 如果您 最多 可以消除 k 个障碍物，请找出从左上角 (0, 0) 到右下角 (m-1, n-1) 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 -1。
 *
 *
 * @author Junho
 * @date 2022/3/21 19:37
 */
public class Main1293 {
    public static void main(String[] args) {
        Main1293 main1293 = new Main1293();
        int[][] test = {{0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0},
        {0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1},
        {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0}};

        main1293.shortestPath(test,5);
    }
    boolean[][] flag;
    Node[][] map;

    class Node{
        int x ;
        int y ;
        int sum;
        int k;
        public Node(int x ,int y){
            this.x = x;
            this.y = y;
        }
        public Node(int x ,int y , int sum){
            this.x = x;
            this.y = y;
            this.sum = sum;
        }
    }
    int[] fx_x = {0 , 1 , 0 , -1};
    int[] fx_y = {-1, 0 , 1  , 0};
    public int shortestPath(int[][] grid, int k) {
        System.out.println(grid.length +" " + grid[0].length);
        flag = new boolean[grid.length][grid[0].length];
        map = new Node[grid.length][grid[0].length];
        Queue<Node> queue = new LinkedList<>();
        Node start = new Node(0 , 0 , 1);
        if(grid[0][0] == 1)
            start.k = 1;
        map[0][0] = start;
        queue.add(start);
        flag[0][0] = true;
        int res = Integer.MAX_VALUE;
        //需要记录下值和
        while (!queue.isEmpty()){
            Node node = queue.poll();
            if(node.x == grid.length - 1 && node.y == grid[0].length - 1){
                if(node.k <= k)
                    return node.sum - 1;
                // res = Math.min(res, node.sum - 1);
            }
             System.out.print(node.x + " " + node.y + " " + node.sum  + " " + node.k +  "==》");
            int x = node.x;
            int y = node.y;

            for(int i = 0 ;i < 4 ; i ++){
                int a = x + fx_x[i];
                int b = y + fx_y[i];
                if(a >= 0 && b >= 0 && a < grid.length && b < grid[0].length ){
//                    !flag[a][b]
                    Node n = new Node(a , b , node.sum + 1);
                    if(grid[a][b] == 1){
                        n.k = node.k + 1;
                    }else{
                        n.k = node.k;
                    }
                    if(map[a][b] == null || map[a][b].k > n.k){
                        flag[a][b] = true;
                        map[a][b] = n;
                        queue.add(n);
                        System.out.print(n.x + " " + n.y + " " + n.sum  + " " + n.k +  " "+ "||");
                    }


                }
            }
             System.out.println();
        }
        return -1;
        // return res == Integer.MAX_VALUE ? -1:res;
    }
//    int[][] grid;
//    boolean[][] flag;
//    int k;
//    class Node{
//        int x ;
//        int y ;
//        int sum;
//        int k;
//        public Node(int x ,int y){
//            this.x = x;
//            this.y = y;
//        }
//        public Node(int x ,int y , int sum){
//            this.x = x;
//            this.y = y;
//            this.sum = sum;
//        }
//    }
//    int[] fx_x = {0 , 1 , 0 , -1};
//    int[] fx_y = {-1, 0 , 1  , 0};
//    public int shortestPath(int[][] g, int kk) {
//        flag = new boolean[g.length][g[0].length];
//        grid = g;
//        Queue<Node> queue = new LinkedList<>();
//        Node start = new Node(0 , 0 , 1);
//        if(grid[0][0] == 1)
//            start.k++;
//        queue.add(start);
//        flag[0][0] = true;
//        int res = Integer.MAX_VALUE;
//        //需要记录下值和
//        while (!queue.isEmpty()){
//            Node node = queue.poll();
//            if(node.x == g.length - 1 && node.y == g[0].length - 1)
//                res = Math.min(res, node.sum);
//            int x = node.x;
//            int y = node.y;
//            for(int i = 0 ;i < 4 ; i ++){
//                int a = x + fx_x[i];
//                int b = y + fx_y[i];
//                if(a >= 0 && b >= 0 && a < grid.length && b < grid[0].length && !flag[a][b]){
//                    flag[a][b] = true;
//                    Node n = new Node(a , b , node.sum + 1);
//                    if(grid[a][b] == 1 && node.k + 1 > k ){
//                        continue;
//                    }else if(grid[a][b] == 1 && node.k + 1 <= k ){
//                        n.k = node.k + 1;
//                    }else if(grid[a][b] == 0 && node.k > k ){
//                        continue;
//                    }else if(grid[a][b] == 0 && node.k <= k ){
//                        n.k = node.k;
//                    }
//                    queue.add(n);
//                }
//            }
//        }
//        return res == Integer.MAX_VALUE ? -1:res;
//    }

}
